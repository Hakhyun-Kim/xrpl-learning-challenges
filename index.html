<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XRPL Learning Challenges</title>
    <script src="https://unpkg.com/xrpl@2.7.0/build/xrpl-latest-min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/javascript/javascript.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.css">
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f7f9fc;
        }
        
        h1, h2, h3 {
            color: #2a5298;
        }
        
        .challenge-container {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            padding: 25px;
            margin-bottom: 30px;
        }
        
        .challenge-description {
            margin-bottom: 20px;
            border-left: 4px solid #2a5298;
            padding-left: 15px;
        }
        
        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .code-editor {
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-bottom: 15px;
            height: 200px;
        }
        
        button {
            background-color: #2a5298;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #1e3c72;
        }
        
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        
        .result-container {
            background-color: #f4f7fa;
            border-radius: 4px;
            padding: 15px;
            margin-top: 15px;
            border-left: 4px solid #2a5298;
            font-family: monospace;
            white-space: pre-wrap;
            max-height: 300px;
            overflow-y: auto;
            display: none;
        }
        
        .hidden {
            display: none;
        }
        
        .success {
            color: #28a745;
            font-weight: bold;
        }
        
        .error {
            color: #dc3545;
            font-weight: bold;
        }
        
        .hint-button {
            background-color: #f8f9fa;
            color: #2a5298;
            border: 1px solid #2a5298;
        }
        
        .hint {
            background-color: #fff8e6;
            border-left: 4px solid #ffc107;
            padding: 10px 15px;
            margin: 10px 0;
            display: none;
        }
        
        .navigation {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }
        
        .progress-container {
            width: 100%;
            margin: 20px 0;
        }
        
        .progress-bar {
            height: 8px;
            background-color: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background-color: #2a5298;
            transition: width 0.3s ease;
            width: 0%;
        }
        
        .completed-badge {
            display: inline-block;
            background-color: #28a745;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            text-align: center;
            line-height: 20px;
            margin-left: 10px;
            font-size: 12px;
        }
        
        .notifications {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
        }
        
        .notification {
            background-color: #2a5298;
            color: white;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            transform: translateX(150%);
            transition: transform 0.3s ease;
            display: flex;
            align-items: center;
        }
        
        .notification.show {
            transform: translateX(0);
        }
        
        .notification.success {
            background-color: #28a745;
            color: white;
        }
        
        .notification-icon {
            margin-right: 10px;
            font-size: 20px;
        }
    </style>
</head>
<body>
    <h1>XRPL Learning Challenges</h1>
    <p>Complete these interactive challenges to learn about building with the XRP Ledger. Each challenge requires you to fill in missing code to make XRPL transactions work correctly.</p>
    
    <div class="progress-container">
        <div class="progress-bar">
            <div class="progress-fill" id="progressBar"></div>
        </div>
    </div>
    
    <div id="challengeContainer"></div>
    
    <div class="notifications" id="notificationsContainer"></div>
    
    <script>
        // Initialize client connection and state
        let xrplClient = null;
        const challenges = [
            {
                id: 'connect',
                title: 'Challenge 1: Connect to the XRP Ledger',
                description: `In this challenge, you need to connect to the XRP Ledger TestNet. 
                              Fill in the missing parameter in the connectToLedger function.`,
                code: `async function connectToLedger() {
  // CHALLENGE: Replace 'YOUR_TESTNET_URL' with the correct WebSocket URL for the XRP Ledger TestNet
  const client = new xrpl.Client('YOUR_TESTNET_URL');
  
  try {
    await client.connect();
    return client;
  } catch (error) {
    console.error("Connection error:", error);
    throw error;
  }
}

// Test the connection
async function testConnection() {
  try {
    const client = await connectToLedger();
    console.log("Successfully connected to the XRP Ledger!");
    
    // Get server info to verify connection
    const serverInfo = await client.request({
      command: "server_info"
    });
    
    console.log("Server info:", serverInfo.result.info.build_version);
    client.disconnect();
    return true;
  } catch (error) {
    console.error("Test failed:", error);
    return false;
  }
}

// Run the test
testConnection();`,
                solution: 'wss://s.altnet.rippletest.net:51233',
                hint: 'The XRP Ledger TestNet is accessible via the WebSocket URL: wss://s.altnet.rippletest.net:51233',
                verifyFn: async (code) => {
                    try {
                        const testNetUrlRegex = /new xrpl\.Client\(['"](wss:\/\/s\.altnet\.rippletest\.net(:51233)?)['"]\)/;
                        return testNetUrlRegex.test(code);
                    } catch (error) {
                        return false;
                    }
                }
            },
            {
                id: 'wallet',
                title: 'Challenge 2: Create a TestNet Wallet',
                description: `Now that we can connect to the TestNet, let's create a new funded wallet.
                              Complete the createTestWallet function to generate a new wallet and fund it using the TestNet faucet.`,
                code: `async function connectToLedger() {
  const client = new xrpl.Client('wss://s.altnet.rippletest.net:51233');
  await client.connect();
  return client;
}

async function createTestWallet(client) {
  try {
    // CHALLENGE: Use the client to create a funded wallet on the TestNet
    // HINT: Look up the fundWallet method
    
    // Replace this line with your code
    const fundedWallet = null;
    
    console.log("Wallet created with address:", fundedWallet.wallet.address);
    console.log("Wallet has balance:", await getXRPBalance(client, fundedWallet.wallet.address));
    
    return fundedWallet.wallet;
  } catch (error) {
    console.error("Error creating wallet:", error);
    throw error;
  }
}

async function getXRPBalance(client, address) {
  const response = await client.request({
    command: "account_info",
    account: address,
    ledger_index: "validated"
  });
  
  return xrpl.dropsToXrp(response.result.account_data.Balance);
}

// Test the wallet creation
async function testWalletCreation() {
  let client;
  try {
    client = await connectToLedger();
    const wallet = await createTestWallet(client);
    console.log("Test successful! Created wallet with address:", wallet.address);
    return true;
  } catch (error) {
    console.error("Test failed:", error);
    return false;
  } finally {
    if (client) client.disconnect();
  }
}

// Run the test
testWalletCreation();`,
                solution: `const fundedWallet = await client.fundWallet();`,
                hint: 'Use client.fundWallet() to generate a new wallet and fund it with the TestNet faucet.',
                verifyFn: async (code) => {
                    try {
                        const fundWalletRegex = /const\s+fundedWallet\s+=\s+await\s+client\.fundWallet\(\s*\)/;
                        return fundWalletRegex.test(code);
                    } catch (error) {
                        return false;
                    }
                }
            },
            {
                id: 'send-xrp',
                title: 'Challenge 3: Send XRP Payment',
                description: `Let's create a function to send XRP from one wallet to another.
                              Complete the sendXRP function by filling in the missing transaction details.`,
                code: `async function connectToLedger() {
  const client = new xrpl.Client('wss://s.altnet.rippletest.net:51233');
  await client.connect();
  return client;
}

async function sendXRP(client, senderWallet, destinationAddress, amount) {
  try {
    // CHALLENGE: Create a Payment transaction to send XRP
    // Convert the amount to drops (XRP's smallest unit)
    const drops = xrpl.xrpToDrops(amount);
    
    // CHALLENGE: Construct the payment transaction object with:
    // - TransactionType: 'Payment'
    // - Account: sender's address
    // - Destination: recipient's address
    // - Amount: amount in drops
    
    // Replace this with your payment transaction object
    const payment = {
      // Fill in the required properties here
    };
    
    // Prepare, sign, and submit the transaction
    const prepared = await client.autofill(payment);
    const signed = senderWallet.sign(prepared);
    const result = await client.submitAndWait(signed.tx_blob);
    
    if (result.result.meta.TransactionResult === "tesSUCCESS") {
      console.log(\`Payment of \${amount} XRP sent successfully to \${destinationAddress}\`);
      console.log(\`Transaction hash: \${result.result.hash}\`);
      return true;
    } else {
      console.error("Transaction failed:", result.result.meta.TransactionResult);
      return false;
    }
  } catch (error) {
    console.error("Error sending XRP:", error);
    return false;
  }
}

// Test sending XRP
async function testSendXRP() {
  let client;
  try {
    client = await connectToLedger();
    
    // Create two test wallets
    const wallet1 = (await client.fundWallet()).wallet;
    const wallet2 = (await client.fundWallet()).wallet;
    
    console.log("Sender address:", wallet1.address);
    console.log("Receiver address:", wallet2.address);
    
    // Send 10 XRP from wallet1 to wallet2
    const success = await sendXRP(client, wallet1, wallet2.address, "10");
    
    if (success) {
      console.log("Payment test completed successfully!");
    } else {
      console.log("Payment test failed.");
    }
    
    return success;
  } catch (error) {
    console.error("Test failed:", error);
    return false;
  } finally {
    if (client) client.disconnect();
  }
}

// Run the test
testSendXRP();`,
                solution: `const payment = {
  TransactionType: 'Payment',
  Account: senderWallet.address,
  Destination: destinationAddress,
  Amount: drops
};`,
                hint: 'The payment object should have 4 properties: TransactionType ("Payment"), Account (sender\'s address), Destination (recipient\'s address), and Amount (the XRP amount in drops).',
                verifyFn: async (code) => {
                    try {
                        return code.includes('TransactionType: \'Payment\'') && 
                               code.includes('Account: senderWallet.address') && 
                               code.includes('Destination: destinationAddress') && 
                               code.includes('Amount: drops');
                    } catch (error) {
                        return false;
                    }
                }
            },
            {
                id: 'check-transaction',
                title: 'Challenge 4: Verify Transaction Status',
                description: `Let's create a function to check the status of a transaction.
                              Complete the checkTransaction function to retrieve and verify a transaction by its hash.`,
                code: `async function connectToLedger() {
  const client = new xrpl.Client('wss://s.altnet.rippletest.net:51233');
  await client.connect();
  return client;
}

async function checkTransaction(client, transactionHash) {
  try {
    // CHALLENGE: Create a request to fetch transaction information
    // - Use the 'tx' command
    // - Include the transaction hash
    
    // Replace this with your request object
    const request = {
      // Fill in the required properties here
    };
    
    const response = await client.request(request);
    
    // Process and display transaction information
    if (response.result.validated) {
      console.log("Transaction found!");
      console.log("Status:", response.result.meta.TransactionResult);
      
      if (response.result.TransactionType === "Payment") {
        const amount = response.result.Amount;
        const isXRP = typeof amount === "string";
        
        if (isXRP) {
          console.log("Payment amount:", xrpl.dropsToXrp(amount), "XRP");
        } else {
          console.log("Payment is for an issued currency");
        }
        
        console.log("From:", response.result.Account);
        console.log("To:", response.result.Destination);
      }
      
      return true;
    } else {
      console.log("Transaction not yet validated");
      return false;
    }
  } catch (error) {
    console.error("Error checking transaction:", error);
    return false;
  }
}

// Test checking a transaction
async function testCheckTransaction() {
  let client;
  try {
    client = await connectToLedger();
    
    // We'll send a transaction to get a transaction hash to check
    const wallet1 = (await client.fundWallet()).wallet;
    const wallet2 = (await client.fundWallet()).wallet;
    
    // Send a payment to get a hash
    const payment = {
      TransactionType: 'Payment',
      Account: wallet1.address,
      Destination: wallet2.address,
      Amount: xrpl.xrpToDrops("5")
    };
    
    const prepared = await client.autofill(payment);
    const signed = wallet1.sign(prepared);
    const result = await client.submitAndWait(signed.tx_blob);
    
    const txHash = result.result.hash;
    console.log("Created transaction with hash:", txHash);
    
    // Now check the transaction
    const success = await checkTransaction(client, txHash);
    
    if (success) {
      console.log("Transaction check completed successfully!");
    } else {
      console.log("Transaction check failed.");
    }
    
    return success;
  } catch (error) {
    console.error("Test failed:", error);
    return false;
  } finally {
    if (client) client.disconnect();
  }
}

// Run the test
testCheckTransaction();`,
                solution: `const request = {
  command: 'tx',
  transaction: transactionHash
};`,
                hint: 'The request object should have 2 properties: command (set to "tx") and transaction (the transaction hash you want to look up).',
                verifyFn: async (code) => {
                    try {
                        return code.includes('command: \'tx\'') && 
                               code.includes('transaction: transactionHash');
                    } catch (error) {
                        return false;
                    }
                }
            },
            {
                id: 'escrow',
                title: 'Challenge 5: Create an Escrow',
                description: `Let's create an escrow payment. Escrows are time-locked payments that can be released after a specific time.
                              Complete the createEscrow function to set up a time-based escrow payment.`,
                code: `async function connectToLedger() {
  const client = new xrpl.Client('wss://s.altnet.rippletest.net:51233');
  await client.connect();
  return client;
}

async function createEscrow(client, senderWallet, destinationAddress, amount, finishAfter) {
  try {
    // Convert the amount to drops
    const drops = xrpl.xrpToDrops(amount);
    
    // Calculate finish time (finishAfter is in seconds from now)
    const date = new Date();
    date.setSeconds(date.getSeconds() + finishAfter);
    
    // CHALLENGE: Create an EscrowCreate transaction
    // - TransactionType: 'EscrowCreate'
    // - Account: sender's address
    // - Destination: recipient's address
    // - Amount: amount in drops
    // - FinishAfter: ripple time when the escrow can be finished (use xrpl.isoTimeToRippleTime())
    
    // Replace this with your escrow transaction object
    const escrowCreate = {
      // Fill in the required properties here
    };
    
    // Prepare, sign, and submit the transaction
    const prepared = await client.autofill(escrowCreate);
    const signed = senderWallet.sign(prepared);
    const result = await client.submitAndWait(signed.tx_blob);
    
    if (result.result.meta.TransactionResult === "tesSUCCESS") {
      console.log(\`Escrow created successfully!\`);
      console.log(\`Sequence number (needed for finishing): \${prepared.Sequence}\`);
      console.log(\`Transaction hash: \${result.result.hash}\`);
      return {
        success: true,
        sequence: prepared.Sequence,
        hash: result.result.hash
      };
    } else {
      console.error("Transaction failed:", result.result.meta.TransactionResult);
      return { success: false };
    }
  } catch (error) {
    console.error("Error creating escrow:", error);
    return { success: false };
  }
}

// Test creating an escrow
async function testCreateEscrow() {
  let client;
  try {
    client = await connectToLedger();
    
    // Create two test wallets
    const wallet1 = (await client.fundWallet()).wallet;
    const wallet2 = (await client.fundWallet()).wallet;
    
    console.log("Sender address:", wallet1.address);
    console.log("Receiver address:", wallet2.address);
    
    // Create an escrow that can be finished after 60 seconds
    const result = await createEscrow(client, wallet1, wallet2.address, "20", 60);
    
    if (result.success) {
      console.log("Escrow test completed successfully!");
    } else {
      console.log("Escrow test failed.");
    }
    
    return result.success;
  } catch (error) {
    console.error("Test failed:", error);
    return false;
  } finally {
    if (client) client.disconnect();
  }
}

// Run the test
testCreateEscrow();`,
                solution: `const escrowCreate = {
  TransactionType: 'EscrowCreate',
  Account: senderWallet.address,
  Destination: destinationAddress,
  Amount: drops,
  FinishAfter: xrpl.isoTimeToRippleTime(date.toISOString())
};`,
                hint: 'The escrowCreate object needs 5 properties: TransactionType ("EscrowCreate"), Account (sender\'s address), Destination (recipient\'s address), Amount (drops), and FinishAfter (ripple time calculated with xrpl.isoTimeToRippleTime()).',
                verifyFn: async (code) => {
                    try {
                        return code.includes('TransactionType: \'EscrowCreate\'') && 
                               code.includes('Account: senderWallet.address') && 
                               code.includes('Destination: destinationAddress') && 
                               code.includes('Amount: drops') &&
                               code.includes('FinishAfter: xrpl.isoTimeToRippleTime');
                    } catch (error) {
                        return false;
                    }
                }
            }
        ];
        
        let currentChallengeIndex = 0;
        let completedChallenges = [];
        let editor = null;
        
        // Initialize the application
        function init() {
            loadChallenge(currentChallengeIndex);
            updateProgressBar();
        }
        
        // Load a challenge
        function loadChallenge(index) {
            const challenge = challenges[index];
            if (!challenge) return;
            
            const container = document.getElementById('challengeContainer');
            
            container.innerHTML = `
                <div class="challenge-container">
                    <h2>${challenge.title} ${completedChallenges.includes(challenge.id) ? '<span class="completed-badge">✓</span>' : ''}</h2>
                    <div class="challenge-description">
                        <p>${challenge.description}</p>
                    </div>
                    <div class="code-header">
                        <h3>Code</h3>
                        <div>
                            <button class="hint-button" id="hintButton">Show Hint</button>
                            <button id="resetButton">Reset Code</button>
                        </div>
                    </div>
                    <div class="hint" id="hintContainer">${challenge.hint}</div>
                    <div class="code-editor" id="codeEditor"></div>
                    <button id="runButton">Run Code</button>
                    <div class="result-container" id="resultContainer"></div>
                    <div class="navigation">
                        <button id="prevButton" ${index === 0 ? 'disabled' : ''}>Previous Challenge</button>
                        <button id="nextButton" ${index === challenges.length - 1 ? 'disabled' : ''}>Next Challenge</button>
                    </div>
                </div>
            `;
            
            // Initialize CodeMirror
            editor = CodeMirror(document.getElementById('codeEditor'), {
                value: challenge.code,
                mode: 'javascript',
                lineNumbers: true,
                theme: 'default',
                lineWrapping: true,
                indentUnit: 2
            });
            
            // Add event listeners
            document.getElementById('hintButton').addEventListener('click', toggleHint);
            document.getElementById('resetButton').addEventListener('click', resetCode);
            document.getElementById('runButton').addEventListener('click', runCode);
            document.getElementById('prevButton').addEventListener('click', loadPreviousChallenge);
            document.getElementById('nextButton').addEventListener('click', loadNextChallenge);
        }
        
        // Toggle hint visibility
        function toggleHint() {
            const hintContainer = document.getElementById('hintContainer');
            const hintButton = document.getElementById('hintButton');
            
            if (hintContainer.style.display === 'block') {
                hintContainer.style.display = 'none';
                hintButton.textContent = 'Show Hint';
            } else {
                hintContainer.style.display = 'block';
                hintButton.textContent = 'Hide Hint';
            }
        }
        
        // Reset code to original state
        function resetCode() {
            editor.setValue(challenges[currentChallengeIndex].code);
        }
        
        // Run the code
        async function runCode() {
            const resultContainer = document.getElementById('resultContainer');
            resultContainer.style.display = 'block';
            resultContainer.innerHTML = 'Running...';
            
            const code = editor.getValue();
            const challenge = challenges[currentChallengeIndex];
            
            // Verify the solution
            try {
                const isCorrect = await challenge.verifyFn(code);
                
                if (isCorrect) {
                    resultContainer.innerHTML = '<span class="success">✓ Success!</span> Your solution is correct.';
                    
                    // Add to completed challenges if not already there
                    if (!completedChallenges.includes(challenge.id)) {
                        completedChallenges.push(challenge.id);
                        updateProgressBar();
                        showNotification('Challenge completed!', true);
                    }
                    
                    // Check if all challenges are completed
                    if (completedChallenges.length === challenges.length) {
                        showNotification('All challenges completed! 🎉', true);
                    }
                    
                    // Update UI to show completion
                    loadChallenge(currentChallengeIndex);
                } else {
                    resultContainer.innerHTML = '<span class="error">✗ Not quite right.</span> Your solution doesn\'t match the expected pattern. Try again or check the hint.';
                }
            } catch (error) {
                resultContainer.innerHTML = `<span class="error">✗ Error:</span> ${error.message}`;
            }
        }
        
        // Load previous challenge
        function loadPreviousChallenge() {
            if (currentChallengeIndex > 0) {
                currentChallengeIndex--;
                loadChallenge(currentChallengeIndex);
            }
        }
        
        // Load next challenge
        function loadNextChallenge() {
            if (currentChallengeIndex < challenges.length - 1) {
                currentChallengeIndex++;
                loadChallenge(currentChallengeIndex);
            }
        }
        
        // Update progress bar
        function updateProgressBar() {
            const progressPercentage = (completedChallenges.length / challenges.length) * 100;
            document.getElementById('progressBar').style.width = `${progressPercentage}%`;
        }
        
        // Show notification
        function showNotification(message, isSuccess = false) {
            const notificationsContainer = document.getElementById('notificationsContainer');
            
            const notification = document.createElement('div');
            notification.className = `notification ${isSuccess ? 'success' : ''}`;
            notification.innerHTML = `
                <span class="notification-icon">${isSuccess ? '🎉' : 'ℹ️'}</span>
                <span>${message}</span>
            `;
            
            notificationsContainer.appendChild(notification);
            
            // Show notification with animation
            setTimeout(() => {
                notification.classList.add('show');
            }, 10);
            
            // Hide and remove after 4 seconds
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => {
                    notificationsContainer.removeChild(notification);
                }, 300);
            }, 4000);
        }
        
        // Initialize when DOM is loaded
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
